// Content script for AI Content Blocker
// Monitors DOM for tweets and applies AI detection pipeline

class AIContentDetector {
  constructor() {
    this.settings = null;
    this.stats = { scanned: 0, blocked: 0 };
    this.observer = null;
    this.processedTweets = new WeakSet(); // Use WeakSet to prevent memory leaks
    
    // Performance optimization: throttle mutation processing
    this.processingQueue = [];
    this.isProcessingScheduled = false;
    
    // AI detection rules (regex-based for MVP)
    this.aiPatterns = [
      /as an ai/i,
      /i am an ai/i,
      /as a language model/i,
      /chatgpt/i,
      /generated by ai/i,
      /made with ai/i,
      /created with ai/i,
      /ai generated/i,
      /gpt-?\d+/i,
      /claude\s*(ai|anthropic)?/i,
      /bard\s*(ai|google)?/i,
      /midjourney/i,
      /dall-?e/i,
      /stable diffusion/i,
      /ai art/i,
      /neural network/i,
      /machine learning/i,
      /deep learning/i,
      /artificial intelligence/i,
      /bot response/i,
      /automated response/i,
      /computer generated/i,
      /synthetically created/i,
      /algorithmically generated/i
    ];

    this.init();
  }

  async init() {
    try {
      console.log('🚀 AI Content Blocker: Starting initialization...');
      
      // Load settings
      await this.loadSettings();
      console.log('⚙️  Settings loaded:', {
        enabled: this.settings.enabled,
        mode: this.settings.mode,
        threshold: this.settings.threshold
      });
      
      if (!this.settings.enabled) {
        console.log('❌ Extension is disabled in settings');
        return;
      }

      // Start observing DOM changes
      this.startObserver();
      
      // Process existing tweets on page load
      this.processExistingTweets();
      
      console.log('✅ AI Content Blocker initialized successfully');
      
      // Make detector available globally for debugging
      window.aiDetector = this;
      
    } catch (error) {
      console.error('❌ Error initializing AI Content Blocker:', error);
    }
  }

  async loadSettings() {
    return new Promise((resolve) => {
      chrome.runtime.sendMessage({ type: 'GET_SETTINGS' }, (response) => {
        this.settings = response.settings || {
          enabled: true,
          mode: 'block',
          threshold: 0.7,
          whitelistedAccounts: []
        };
        resolve();
      });
    });
  }

  startObserver() {
    // Target the main timeline container
    const timelineSelectors = [
      '[data-testid="primaryColumn"]',
      '[aria-label="Timeline: Your Home Timeline"]',
      '[aria-label="Timeline"]',
      'main[role="main"]'
    ];

    let targetElement = null;
    for (const selector of timelineSelectors) {
      targetElement = document.querySelector(selector);
      if (targetElement) break;
    }

    if (!targetElement) {
      // Fallback to document body
      targetElement = document.body;
    }

    // Performance optimization: throttled mutation processing
    const flushProcessingQueue = () => {
      this.isProcessingScheduled = false;
      const elementsToProcess = [...this.processingQueue];
      this.processingQueue.length = 0; // Clear the queue
      
      // Process in batches to avoid blocking the UI
      const processBatch = (startIndex = 0) => {
        const batchSize = 5; // Process 5 tweets per frame
        const endIndex = Math.min(startIndex + batchSize, elementsToProcess.length);
        
        for (let i = startIndex; i < endIndex; i++) {
          this.processTweet(elementsToProcess[i]);
        }
        
        if (endIndex < elementsToProcess.length) {
          // Schedule next batch
          requestAnimationFrame(() => processBatch(endIndex));
        }
      };
      
      if (elementsToProcess.length > 0) {
        processBatch();
      }
    };

    this.observer = new MutationObserver((mutations) => {
      // Collect all new tweet elements in a single pass
      const newTweetElements = [];
      
      mutations.forEach((mutation) => {
        mutation.addedNodes.forEach((node) => {
          if (node.nodeType === Node.ELEMENT_NODE) {
            const tweets = this.findTweetElements(node);
            newTweetElements.push(...tweets);
          }
        });
      });
      
      // Add unique elements to processing queue
      newTweetElements.forEach(element => {
        if (!this.processingQueue.includes(element)) {
          this.processingQueue.push(element);
        }
      });
      
      // Throttle processing using requestIdleCallback for better performance
      if (!this.isProcessingScheduled && this.processingQueue.length > 0) {
        this.isProcessingScheduled = true;
        
        // Use requestIdleCallback if available, fallback to requestAnimationFrame
        if (window.requestIdleCallback) {
          requestIdleCallback(flushProcessingQueue, { timeout: 500 });
        } else {
          requestAnimationFrame(flushProcessingQueue);
        }
      }
    });

    this.observer.observe(targetElement, {
      childList: true,
      subtree: true
    });
  }

  processExistingTweets() {
    const tweetElements = this.findTweetElements(document);
    tweetElements.forEach(element => this.processTweet(element));
  }

  processTweetElements(rootElement) {
    const tweetElements = this.findTweetElements(rootElement);
    tweetElements.forEach(element => this.processTweet(element));
  }

  findTweetElements(rootElement) {
    const tweetSelectors = [
      '[data-testid="tweet"]',
      'article[role="article"]'
    ];

    // Use a more efficient approach - check if root is a tweet first
    if (rootElement.matches) {
      for (const selector of tweetSelectors) {
        if (rootElement.matches(selector)) {
          return [rootElement];
        }
      }
    }

    // Only search children if root isn't a tweet
    const tweets = [];
    for (const selector of tweetSelectors) {
      const elements = rootElement.querySelectorAll(selector);
      tweets.push(...elements);
    }

    return tweets; // Already unique since we're using different selectors
  }

  async processTweet(tweetElement) {
    try {
      // Skip if already processed using WeakSet (more efficient)
      if (this.processedTweets.has(tweetElement)) {
        return;
      }
      this.processedTweets.add(tweetElement);

      // Extract tweet content
      const tweetData = this.extractTweetData(tweetElement);
      if (!tweetData.text && !tweetData.media.length) {
        return; // Skip empty tweets
      }

      this.stats.scanned++;

      // Check if account is whitelisted
      if (this.isWhitelisted(tweetData.author)) {
        return;
      }

      // Run AI detection pipeline
      const aiScore = this.detectAI(tweetData);
      
      if (aiScore >= this.settings.threshold) {
        this.stats.blocked++;
        
        if (this.settings.mode === 'block') {
          this.blockTweet(tweetElement, aiScore);
        } else {
          this.flagTweet(tweetElement, aiScore);
        }
      }

      // Update stats more frequently for better real-time updates
      if (this.stats.scanned % 5 === 0 || this.stats.blocked > 0) {
        this.updateStats();
      }
    } catch (error) {
      console.error('❌ Error processing tweet:', error);
      // Continue processing other tweets even if one fails
    }
  }

  extractTweetData(tweetElement) {
    const data = {
      text: '',
      author: '',
      media: [],
      hashtags: [],
      mentions: []
    };

    // Extract text content - use more specific selectors first
    const textElement = tweetElement.querySelector('[data-testid="tweetText"]');
    if (textElement) {
      data.text = textElement.textContent.trim();
    } else {
      // Fallback for older tweet structure
      const textElements = tweetElement.querySelectorAll('.css-901oao.css-16my406');
      textElements.forEach(el => {
        data.text += el.textContent + ' ';
      });
      data.text = data.text.trim();
    }

    // Extract author - single query instead of multiple
    const authorElement = tweetElement.querySelector('[data-testid="User-Name"] a') || 
                         tweetElement.querySelector('.css-901oao.css-bfa6kz');
    if (authorElement) {
      data.author = authorElement.textContent.trim();
    }

    // Extract hashtags and mentions from text (only if text exists)
    if (data.text) {
      data.hashtags = data.text.match(/#\w+/g) || [];
      data.mentions = data.text.match(/@\w+/g) || [];
    }

    // Extract media info - only search if needed
    const mediaElements = tweetElement.querySelectorAll('img[alt], video');
    if (mediaElements.length > 0) {
      mediaElements.forEach(el => {
        data.media.push({
          type: el.tagName.toLowerCase(),
          alt: el.alt || '',
          src: el.src || ''
        });
      });
    }

    return data;
  }

  detectAI(tweetData) {
    let score = 0;
    const text = tweetData.text.toLowerCase();

    // Text-based pattern matching
    for (const pattern of this.aiPatterns) {
      if (pattern.test(text)) {
        score += 0.3; // Each pattern match adds to confidence
      }
    }

    // Media-based detection (basic)
    tweetData.media.forEach(media => {
      if (media.alt) {
        const altText = media.alt.toLowerCase();
        for (const pattern of this.aiPatterns) {
          if (pattern.test(altText)) {
            score += 0.2;
          }
        }
      }
    });

    // Author bio check (basic heuristic)
    if (tweetData.author.toLowerCase().includes('ai') || 
        tweetData.author.toLowerCase().includes('bot')) {
      score += 0.1;
    }

    // Hashtag check
    const aiHashtags = ['#ai', '#chatgpt', '#midjourney', '#dalle', '#aiart', '#aiimage'];
    tweetData.hashtags.forEach(hashtag => {
      if (aiHashtags.includes(hashtag.toLowerCase())) {
        score += 0.2;
      }
    });

    return Math.min(score, 1.0); // Cap at 1.0
  }

  isWhitelisted(author) {
    return this.settings.whitelistedAccounts.some(account => 
      author.toLowerCase().includes(account.toLowerCase())
    );
  }

  blockTweet(tweetElement, confidence) {
    // Prevent re-blocking already blocked tweets
    if (tweetElement.classList.contains('ai-blocked')) {
      return;
    }

    console.log(`🚫 Blocking tweet with ${Math.round(confidence * 100)}% confidence`);
    
    // Create blocked content placeholder
    const placeholder = document.createElement('div');
    placeholder.className = 'ai-content-blocked';
    placeholder.style.cssText = 'border: 1px solid #e1e8ed; border-radius: 12px; padding: 16px; margin: 8px 0; background: #f7f9fa;';
    
    placeholder.innerHTML = `
      <div class="ai-block-content">
        <div class="ai-block-header" style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
          <div style="display: flex; align-items: center; gap: 8px;">
            <span class="ai-block-icon">🤖</span>
            <span class="ai-block-text" style="font-weight: 500; color: #536471;">AI-generated content hidden</span>
          </div>
          <span class="ai-block-confidence" style="font-size: 12px; color: #657786; background: #e1e8ed; padding: 2px 8px; border-radius: 12px; cursor: default;">${Math.round(confidence * 100)}% confidence</span>
        </div>
        <button class="ai-show-anyway" style="background: #1d9bf0; color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer; font-size: 14px; width: 100%;">Show anyway</button>
      </div>
    `;

    // Store original content and element reference
    placeholder.originalContent = tweetElement.innerHTML;
    placeholder.originalElement = tweetElement;

    // Add show/hide functionality with event delegation
    const showButton = placeholder.querySelector('.ai-show-anyway');
    showButton.addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      console.log('👁️  User clicked "Show anyway" for blocked tweet');
      this.toggleTweetVisibility(placeholder);
    });

    // Prevent clicks on confidence text from bubbling
    const confidenceSpan = placeholder.querySelector('.ai-block-confidence');
    confidenceSpan.addEventListener('click', (e) => {
      e.stopPropagation();
      e.preventDefault();
      console.log('ℹ️  Confidence percentage clicked (no action)');
    });

    // Replace tweet content
    tweetElement.innerHTML = '';
    tweetElement.appendChild(placeholder);
    tweetElement.classList.add('ai-blocked');
    
    console.log('✅ Tweet successfully blocked and placeholder inserted');
  }

  flagTweet(tweetElement, confidence) {
    console.log(`🏷️  Flagging tweet with ${Math.round(confidence * 100)}% confidence`);
    
    // Apply minimal purple gradient background instead of flag banner
    tweetElement.style.background = 'linear-gradient(135deg, rgba(155, 89, 182, 0.08) 0%, rgba(142, 68, 173, 0.12) 100%)';
    tweetElement.style.borderLeft = '3px solid rgba(155, 89, 182, 0.4)';
    tweetElement.style.transition = 'all 0.3s ease';
    
    // Add class for identification and potential custom styling
    tweetElement.classList.add('ai-flagged');
    
    // Store confidence for potential tooltip or debugging
    tweetElement.setAttribute('data-ai-confidence', Math.round(confidence * 100));
    
    console.log('✅ Tweet successfully flagged with purple gradient');
  }

  toggleTweetVisibility(placeholder) {
    if (placeholder.originalContent) {
      // Show original content
      placeholder.originalElement.innerHTML = placeholder.originalContent;
      placeholder.originalElement.classList.remove('ai-blocked');
      
      // Remove any existing hide buttons first
      const existingHideButtons = placeholder.originalElement.querySelectorAll('.ai-hide-again');
      existingHideButtons.forEach(btn => btn.remove());
      
      // Add hide button
      const hideButton = document.createElement('div');
      hideButton.className = 'ai-hide-again';
      hideButton.style.cssText = 'margin-top: 10px; text-align: center;';
      hideButton.innerHTML = `
        <button class="ai-hide-button" style="background: #1d9bf0; color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer; font-size: 14px;">Hide AI content</button>
      `;
      
      const hideBtn = hideButton.querySelector('.ai-hide-button');
      hideBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        // Remove the hide button and re-block the tweet
        hideButton.remove();
        this.blockTweet(placeholder.originalElement, 1.0);
      });
      
      placeholder.originalElement.appendChild(hideButton);
    }
  }

  updateStats() {
    console.log(`📊 Updating stats: scanned=${this.stats.scanned}, blocked=${this.stats.blocked}`);
    
    chrome.runtime.sendMessage({
      type: 'UPDATE_STATS',
      scanned: this.stats.scanned,
      blocked: this.stats.blocked
    }, (response) => {
      if (chrome.runtime.lastError) {
        console.error('❌ Error updating stats:', chrome.runtime.lastError);
      } else {
        console.log('✅ Stats updated successfully');
      }
    });
    
    // Reset local counters
    this.stats.scanned = 0;
    this.stats.blocked = 0;
  }
}

// Initialize the detector when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    new AIContentDetector();
  });
} else {
  new AIContentDetector();
}

// Add debugging helper functions to window
window.aiDebugger = {
  testAIText: () => {
    // Create a fake tweet element for testing
    const testTweet = document.createElement('div');
    testTweet.innerHTML = `
      <div data-testid="tweetText">This was generated by ChatGPT, an AI language model.</div>
      <div data-testid="User-Name"><a>TestUser</a></div>
    `;
    document.body.appendChild(testTweet);
    
    if (window.aiDetector) {
      window.aiDetector.processTweet(testTweet);
      console.log('✅ Test AI tweet created and processed');
    } else {
      console.log('❌ AI Detector not initialized');
    }
    
    return testTweet;
  },
  
  getStats: () => {
    return window.aiDetector ? window.aiDetector.stats : 'Detector not initialized';
  },
  
  resetStats: () => {
    if (window.aiDetector) {
      window.aiDetector.stats = { scanned: 0, blocked: 0 };
      console.log('📊 Stats reset');
    }
  },
  
  testDetection: (text) => {
    if (!window.aiDetector) return 'Detector not initialized';
    
    const mockData = {
      text: text,
      author: 'TestUser',
      media: [],
      hashtags: [],
      mentions: []
    };
    
    const score = window.aiDetector.detectAI(mockData);
    console.log(`🤖 Detection test: "${text}" scored ${score.toFixed(3)}`);
    return score;
  },
  
  testFlagStyle: () => {
    // Find the first tweet and apply the new flag style for testing
    const tweets = document.querySelectorAll('[data-testid="tweet"]');
    if (tweets.length > 0) {
      const testTweet = tweets[0];
      window.aiDetector.flagTweet(testTweet, 0.85);
      console.log('🎨 Applied purple gradient flag to first tweet for testing');
      return 'Flag style applied to first tweet';
    }
    return 'No tweets found to test on';
  }
};

console.log('🛠️  Debug helper loaded. Use window.aiDebugger for testing:');
console.log('   - aiDebugger.testAIText() - Create test AI tweet');
console.log('   - aiDebugger.getStats() - View current stats');
console.log('   - aiDebugger.testDetection("text") - Test AI detection on text');
console.log('   - aiDebugger.testFlagStyle() - Test new purple gradient flag style');
