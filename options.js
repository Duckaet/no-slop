// Options page script for AI Content Blocker
// Handles advanced settings management and UI interactions

class OptionsController {
  constructor() {
    this.settings = null;
    this.defaultSettings = {
      enabled: true,
      mode: 'block',
      threshold: 0.7,
      showStats: true,
      whitelistedAccounts: [],
      customRules: [],
      telemetryEnabled: false
    };
    
    // Built-in AI detection patterns for display
    this.builtInPatterns = [
      '/as an ai/i',
      '/i am an ai/i',
      '/as a language model/i',
      '/chatgpt/i',
      '/generated by ai/i',
      '/made with ai/i',
      '/created with ai/i',
      '/ai generated/i',
      '/gpt-?\\d+/i',
      '/claude\\s*(ai|anthropic)?/i',
      '/bard\\s*(ai|google)?/i',
      '/midjourney/i',
      '/dall-?e/i',
      '/stable diffusion/i',
      '/ai art/i',
      '/neural network/i',
      '/machine learning/i',
      '/deep learning/i',
      '/artificial intelligence/i',
      '/bot response/i',
      '/automated response/i',
      '/computer generated/i',
      '/synthetically created/i',
      '/algorithmically generated/i'
    ];

    this.init();
  }

  async init() {
    await this.loadSettings();
    this.setupEventListeners();
    this.setupNavigation();
    this.populateUI();
    this.showSection('general');
  }

  async loadSettings() {
    const result = await chrome.storage.sync.get(['settings']);
    this.settings = { ...this.defaultSettings, ...result.settings };
  }

  async saveSettings() {
    await chrome.storage.sync.set({ settings: this.settings });
    this.showSaveConfirmation();
  }

  setupEventListeners() {
    // General settings
    this.setupToggle('extensionEnabled', 'enabled');
    this.setupSelect('detectionMode', 'mode');
    this.setupSlider('confidenceThreshold', 'threshold', (value) => {
      document.getElementById('thresholdDisplay').textContent = `${Math.round(value * 100)}%`;
    });
    this.setupToggle('showStats', 'showStats');
    this.setupToggle('telemetryEnabled', 'telemetryEnabled');

    // Custom rules
    this.setupTextarea('customRules', 'customRules');

    // Whitelist management
    this.setupWhitelistControls();

    // Footer buttons
    document.getElementById('saveBtn').addEventListener('click', () => {
      this.saveSettings();
    });

    document.getElementById('resetBtn').addEventListener('click', () => {
      this.resetToDefaults();
    });

    document.getElementById('clearDataBtn').addEventListener('click', () => {
      this.clearAllData();
    });
  }

  setupToggle(elementId, settingKey) {
    const element = document.getElementById(elementId);
    element.checked = this.settings[settingKey];
    element.addEventListener('change', (e) => {
      this.settings[settingKey] = e.target.checked;
    });
  }

  setupSelect(elementId, settingKey) {
    const element = document.getElementById(elementId);
    element.value = this.settings[settingKey];
    element.addEventListener('change', (e) => {
      this.settings[settingKey] = e.target.value;
    });
  }

  setupSlider(elementId, settingKey, callback) {
    const element = document.getElementById(elementId);
    element.value = this.settings[settingKey];
    
    const updateValue = (e) => {
      const value = parseFloat(e.target.value);
      this.settings[settingKey] = value;
      if (callback) callback(value);
    };

    element.addEventListener('input', updateValue);
    element.addEventListener('change', updateValue);
    
    // Initial update
    if (callback) callback(this.settings[settingKey]);
  }

  setupTextarea(elementId, settingKey) {
    const element = document.getElementById(elementId);
    element.value = Array.isArray(this.settings[settingKey]) 
      ? this.settings[settingKey].join('\n')
      : this.settings[settingKey];
    
    element.addEventListener('input', (e) => {
      const lines = e.target.value.split('\n').filter(line => line.trim());
      this.settings[settingKey] = lines;
    });
  }

  setupWhitelistControls() {
    const input = document.getElementById('whitelistInput');
    const addBtn = document.getElementById('addWhitelistBtn');

    const addAccount = () => {
      const account = input.value.trim();
      if (account && !this.settings.whitelistedAccounts.includes(account)) {
        this.settings.whitelistedAccounts.push(account);
        input.value = '';
        this.updateWhitelistDisplay();
      }
    };

    addBtn.addEventListener('click', addAccount);
    input.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        addAccount();
      }
    });

    this.updateWhitelistDisplay();
  }

  updateWhitelistDisplay() {
    const container = document.getElementById('whitelistContainer');
    const emptyState = document.getElementById('emptyWhitelist');

    if (this.settings.whitelistedAccounts.length === 0) {
      emptyState.style.display = 'block';
      // Clear any existing items
      const items = container.querySelectorAll('.whitelist-item');
      items.forEach(item => item.remove());
    } else {
      emptyState.style.display = 'none';
      
      // Clear existing items
      const items = container.querySelectorAll('.whitelist-item');
      items.forEach(item => item.remove());

      // Add current accounts
      this.settings.whitelistedAccounts.forEach((account, index) => {
        const item = document.createElement('div');
        item.className = 'whitelist-item';
        item.innerHTML = `
          <span class="whitelist-name">${this.escapeHtml(account)}</span>
          <button class="remove-btn" data-index="${index}">Remove</button>
        `;

        const removeBtn = item.querySelector('.remove-btn');
        removeBtn.addEventListener('click', () => {
          this.removeWhitelistAccount(index);
        });

        container.appendChild(item);
      });
    }
  }

  removeWhitelistAccount(index) {
    this.settings.whitelistedAccounts.splice(index, 1);
    this.updateWhitelistDisplay();
  }

  setupNavigation() {
    const navButtons = document.querySelectorAll('.nav-btn');
    navButtons.forEach(btn => {
      btn.addEventListener('click', (e) => {
        const sectionId = e.target.dataset.section;
        this.showSection(sectionId);
        
        // Update active state
        navButtons.forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
      });
    });
  }

  showSection(sectionId) {
    // Hide all sections
    const sections = document.querySelectorAll('.settings-section');
    sections.forEach(section => section.classList.remove('active'));

    // Show target section
    const targetSection = document.getElementById(sectionId);
    if (targetSection) {
      targetSection.classList.add('active');
    }

    // Update navigation
    const navButtons = document.querySelectorAll('.nav-btn');
    navButtons.forEach(btn => {
      btn.classList.toggle('active', btn.dataset.section === sectionId);
    });
  }

  populateUI() {
    this.populatePatternsList();
    this.updateWhitelistDisplay();
  }

  populatePatternsList() {
    const container = document.getElementById('patternsList');
    container.innerHTML = '';

    this.builtInPatterns.forEach(pattern => {
      const item = document.createElement('div');
      item.className = 'pattern-item';
      item.textContent = pattern;
      container.appendChild(item);
    });
  }

  async resetToDefaults() {
    const confirmed = confirm('Are you sure you want to reset all settings to defaults? This cannot be undone.');
    if (confirmed) {
      this.settings = { ...this.defaultSettings };
      await this.saveSettings();
      
      // Reload the page to refresh UI
      window.location.reload();
    }
  }

  async clearAllData() {
    const confirmed = confirm(
      'Are you sure you want to clear all extension data? This will:\n\n' +
      '• Reset all settings to defaults\n' +
      '• Clear all statistics\n' +
      '• Remove all whitelisted accounts\n' +
      '• Delete custom rules\n\n' +
      'This action cannot be undone.'
    );
    
    if (confirmed) {
      // Clear all storage
      await chrome.storage.sync.clear();
      await chrome.storage.local.clear();
      
      // Reset settings
      this.settings = { ...this.defaultSettings };
      await chrome.storage.sync.set({ settings: this.settings });
      
      alert('All data has been cleared. The page will now reload.');
      window.location.reload();
    }
  }

  showSaveConfirmation() {
    const saveBtn = document.getElementById('saveBtn');
    const originalText = saveBtn.textContent;
    
    saveBtn.textContent = 'Saved!';
    saveBtn.style.background = '#4caf50';
    saveBtn.disabled = true;
    
    setTimeout(() => {
      saveBtn.textContent = originalText;
      saveBtn.style.background = '';
      saveBtn.disabled = false;
    }, 2000);
  }

  escapeHtml(text) {
    const map = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#039;'
    };
    return text.replace(/[&<>"']/g, (m) => map[m]);
  }
}

// Initialize options controller when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  new OptionsController();
});

// Handle keyboard navigation
document.addEventListener('keydown', (e) => {
  // Save with Ctrl+S
  if (e.ctrlKey && e.key === 's') {
    e.preventDefault();
    document.getElementById('saveBtn').click();
  }
  
  // Navigate sections with Ctrl+1-4
  if (e.ctrlKey && ['1', '2', '3', '4'].includes(e.key)) {
    e.preventDefault();
    const sections = ['general', 'detection', 'whitelist', 'privacy'];
    const sectionIndex = parseInt(e.key) - 1;
    if (sections[sectionIndex]) {
      const navBtn = document.querySelector(`[data-section="${sections[sectionIndex]}"]`);
      if (navBtn) navBtn.click();
    }
  }
});
