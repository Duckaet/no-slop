// Test file for AI Content Blocker
// Run with: npm test

/**
 * Mock Chrome APIs for testing
 */
global.chrome = {
  runtime: {
    sendMessage: jest.fn(),
    onMessage: {
      addListener: jest.fn()
    },
    onInstalled: {
      addListener: jest.fn()
    }
  },
  storage: {
    sync: {
      get: jest.fn(),
      set: jest.fn()
    },
    local: {
      get: jest.fn(),
      set: jest.fn()
    }
  },
  tabs: {
    onUpdated: {
      addListener: jest.fn()
    }
  },
  scripting: {
    executeScript: jest.fn()
  }
};

/**
 * Mock DOM elements for content script testing
 */
const mockTweet = {
  innerHTML: 'This is a test tweet generated by ChatGPT for testing purposes.',
  textContent: 'This is a test tweet generated by ChatGPT for testing purposes.',
  querySelector: jest.fn(),
  querySelectorAll: jest.fn(() => []),
  classList: {
    add: jest.fn(),
    remove: jest.fn(),
    toggle: jest.fn()
  },
  appendChild: jest.fn(),
  insertBefore: jest.fn()
};

/**
 * Test AI Detection Patterns
 */
describe('AI Content Detection', () => {
  test('should detect ChatGPT mentions', () => {
    const text = 'This content was generated by ChatGPT';
    const patterns = [/chatgpt/i];
    
    const hasAIPattern = patterns.some(pattern => pattern.test(text));
    expect(hasAIPattern).toBe(true);
  });

  test('should detect "as an AI" phrases', () => {
    const text = 'As an AI language model, I cannot provide that information';
    const patterns = [/as an ai/i];
    
    const hasAIPattern = patterns.some(pattern => pattern.test(text));
    expect(hasAIPattern).toBe(true);
  });

  test('should not flag normal human text', () => {
    const text = 'Just had a great coffee this morning! Beautiful weather today.';
    const patterns = [
      /as an ai/i,
      /chatgpt/i,
      /generated by ai/i,
      /ai generated/i
    ];
    
    const hasAIPattern = patterns.some(pattern => pattern.test(text));
    expect(hasAIPattern).toBe(false);
  });

  test('should detect AI art hashtags', () => {
    const text = 'Check out this amazing image! #AIart #midjourney #dalle';
    const patterns = [/midjourney/i, /dall-?e/i, /#aiart/i];
    
    const hasAIPattern = patterns.some(pattern => pattern.test(text));
    expect(hasAIPattern).toBe(true);
  });
});

/**
 * Test Score Calculation
 */
describe('AI Detection Scoring', () => {
  function calculateAIScore(text, media = [], author = '') {
    let score = 0;
    const patterns = [
      /as an ai/i,
      /chatgpt/i,
      /generated by ai/i,
      /midjourney/i,
      /dalle/i
    ];

    // Text pattern matching
    for (const pattern of patterns) {
      if (pattern.test(text.toLowerCase())) {
        score += 0.3;
      }
    }

    // Author check
    if (author.toLowerCase().includes('ai') || author.toLowerCase().includes('bot')) {
      score += 0.1;
    }

    // Media check
    media.forEach(m => {
      if (m.alt && patterns.some(p => p.test(m.alt.toLowerCase()))) {
        score += 0.2;
      }
    });

    return Math.min(score, 1.0);
  }

  test('should score high for obvious AI content', () => {
    const text = 'As an AI language model created by ChatGPT, I generated this image using Midjourney';
    const score = calculateAIScore(text);
    expect(score).toBeGreaterThan(0.8);
  });

  test('should score low for human content', () => {
    const text = 'Had a great day at the park with friends';
    const score = calculateAIScore(text);
    expect(score).toBe(0);
  });

  test('should consider author information', () => {
    const text = 'Hello everyone!';
    const score = calculateAIScore(text, [], 'AI Bot Assistant');
    expect(score).toBeGreaterThan(0);
  });

  test('should consider media alt text', () => {
    const text = 'Check this out:';
    const media = [{ alt: 'Image generated by DALL-E' }];
    const score = calculateAIScore(text, media);
    expect(score).toBeGreaterThan(0);
  });
});

/**
 * Test Settings Management
 */
describe('Settings Management', () => {
  const defaultSettings = {
    enabled: true,
    mode: 'block',
    threshold: 0.7,
    whitelistedAccounts: []
  };

  test('should have correct default settings', () => {
    expect(defaultSettings.enabled).toBe(true);
    expect(defaultSettings.mode).toBe('block');
    expect(defaultSettings.threshold).toBe(0.7);
    expect(Array.isArray(defaultSettings.whitelistedAccounts)).toBe(true);
  });

  test('should validate threshold range', () => {
    const isValidThreshold = (threshold) => {
      return threshold >= 0.1 && threshold <= 1.0;
    };

    expect(isValidThreshold(0.5)).toBe(true);
    expect(isValidThreshold(0.05)).toBe(false);
    expect(isValidThreshold(1.5)).toBe(false);
  });

  test('should validate mode values', () => {
    const validModes = ['block', 'flag'];
    
    expect(validModes.includes('block')).toBe(true);
    expect(validModes.includes('flag')).toBe(true);
    expect(validModes.includes('invalid')).toBe(false);
  });
});

/**
 * Test Whitelist Functionality
 */
describe('Whitelist Management', () => {
  function isWhitelisted(author, whitelistedAccounts) {
    return whitelistedAccounts.some(account => 
      author.toLowerCase().includes(account.toLowerCase())
    );
  }

  test('should whitelist exact matches', () => {
    const whitelist = ['@elonmusk', 'verified_user'];
    expect(isWhitelisted('@elonmusk', whitelist)).toBe(true);
    expect(isWhitelisted('verified_user', whitelist)).toBe(true);
  });

  test('should whitelist partial matches', () => {
    const whitelist = ['elon'];
    expect(isWhitelisted('@elonmusk', whitelist)).toBe(true);
    expect(isWhitelisted('Elon Musk', whitelist)).toBe(true);
  });

  test('should not whitelist non-matches', () => {
    const whitelist = ['@elonmusk'];
    expect(isWhitelisted('@jeffbezos', whitelist)).toBe(false);
    expect(isWhitelisted('random_user', whitelist)).toBe(false);
  });

  test('should be case insensitive', () => {
    const whitelist = ['TESTUSER'];
    expect(isWhitelisted('testuser', whitelist)).toBe(true);
    expect(isWhitelisted('TestUser', whitelist)).toBe(true);
  });
});

/**
 * Test DOM Manipulation
 */
describe('DOM Manipulation', () => {
  test('should create blocked content placeholder', () => {
    const createBlockedPlaceholder = (confidence) => {
      return {
        className: 'ai-content-blocked',
        innerHTML: `
          <div class="ai-block-content">
            <div class="ai-block-header">
              <span class="ai-block-icon">ðŸ¤–</span>
              <span class="ai-block-text">AI-generated content hidden</span>
              <span class="ai-block-confidence">${Math.round(confidence * 100)}% confidence</span>
            </div>
            <button class="ai-show-anyway">Show anyway</button>
          </div>
        `
      };
    };

    const placeholder = createBlockedPlaceholder(0.85);
    expect(placeholder.className).toBe('ai-content-blocked');
    expect(placeholder.innerHTML).toContain('85% confidence');
    expect(placeholder.innerHTML).toContain('Show anyway');
  });

  test('should create flagged content indicator', () => {
    const createFlagIndicator = (confidence) => {
      return {
        className: 'ai-content-flag',
        innerHTML: `
          <span class="ai-flag-icon">ðŸ¤–</span>
          <span class="ai-flag-text">Possible AI content (${Math.round(confidence * 100)}%)</span>
        `
      };
    };

    const flag = createFlagIndicator(0.75);
    expect(flag.className).toBe('ai-content-flag');
    expect(flag.innerHTML).toContain('75%');
  });
});

/**
 * Test Performance Helpers
 */
describe('Performance Utilities', () => {
  test('should format large numbers correctly', () => {
    const formatNumber = (num) => {
      if (num >= 1000000) {
        return (num / 1000000).toFixed(1) + 'M';
      } else if (num >= 1000) {
        return (num / 1000).toFixed(1) + 'K';
      }
      return num.toString();
    };

    expect(formatNumber(500)).toBe('500');
    expect(formatNumber(1500)).toBe('1.5K');
    expect(formatNumber(1500000)).toBe('1.5M');
  });

  test('should calculate percentage correctly', () => {
    const calculatePercentage = (blocked, total) => {
      return total > 0 ? ((blocked / total) * 100).toFixed(1) : '0';
    };

    expect(calculatePercentage(25, 100)).toBe('25.0');
    expect(calculatePercentage(1, 3)).toBe('33.3');
    expect(calculatePercentage(0, 0)).toBe('0');
  });
});

/**
 * Integration Test Simulation
 */
describe('Integration Tests', () => {
  test('should process tweet with AI content correctly', () => {
    const processTweet = (tweetElement, settings) => {
      const text = tweetElement.textContent;
      const patterns = [/chatgpt/i, /as an ai/i];
      
      let score = 0;
      patterns.forEach(pattern => {
        if (pattern.test(text)) score += 0.3;
      });

      if (score >= settings.threshold) {
        if (settings.mode === 'block') {
          tweetElement.classList.add('ai-blocked');
          return 'blocked';
        } else {
          tweetElement.classList.add('ai-flagged');
          return 'flagged';
        }
      }
      return 'passed';
    };

    const mockTweetElement = {
      textContent: 'This was generated by ChatGPT',
      classList: { add: jest.fn() }
    };

    const settings = { threshold: 0.2, mode: 'block' };
    const result = processTweet(mockTweetElement, settings);

    expect(result).toBe('blocked');
    expect(mockTweetElement.classList.add).toHaveBeenCalledWith('ai-blocked');
  });
});
